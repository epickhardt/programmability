---
published: true
date: '2021-02-04 18:20 +0100'
title: pyATS series - Parsing like a pro
author: Antoine Orsoni
excerpt: Explore pyATS libraries and parse your first CLI output
tags:
  - iosxr
  - cisco
  - pyATS
position: hidden
---
{% include toc icon="table" title="Table of Contents" %}
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; margin: 0; font-size: small; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding: 0 5px 0 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding: 0 5px 0 5px; }
body .hll { background-color: #ffffcc }
body { background: #f8f8f8; }
body .c { color: #008800; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #AA22FF; font-weight: bold } /* Keyword */
body .o { color: #666666 } /* Operator */
body .ch { color: #008800; font-style: italic } /* Comment.Hashbang */
body .cm { color: #008800; font-style: italic } /* Comment.Multiline */
body .cp { color: #008800 } /* Comment.Preproc */
body .cpf { color: #008800; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #008800; font-style: italic } /* Comment.Single */
body .cs { color: #008800; font-weight: bold } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #AA22FF; font-weight: bold } /* Keyword.Constant */
body .kd { color: #AA22FF; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #AA22FF; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #AA22FF } /* Keyword.Pseudo */
body .kr { color: #AA22FF; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #00BB00; font-weight: bold } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BB4444 } /* Literal.String */
body .na { color: #BB4444 } /* Name.Attribute */
body .nb { color: #AA22FF } /* Name.Builtin */
body .nc { color: #0000FF } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #00A000 } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #B8860B } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BB4444 } /* Literal.String.Affix */
body .sb { color: #BB4444 } /* Literal.String.Backtick */
body .sc { color: #BB4444 } /* Literal.String.Char */
body .dl { color: #BB4444 } /* Literal.String.Delimiter */
body .sd { color: #BB4444; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BB4444 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BB4444 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BB4444 } /* Literal.String.Single */
body .ss { color: #B8860B } /* Literal.String.Symbol */
body .bp { color: #AA22FF } /* Name.Builtin.Pseudo */
body .fm { color: #00A000 } /* Name.Function.Magic */
body .vc { color: #B8860B } /* Name.Variable.Class */
body .vg { color: #B8860B } /* Name.Variable.Global */
body .vi { color: #B8860B } /* Name.Variable.Instance */
body .vm { color: #B8860B } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
![pyats_hello2.jpg]({{site.baseurl}}/images/pyats_hello2.jpg){: .align-center}

# pyATS overview

Ever dreamed of a test framework that could be used across multiple platforms, OS and vendors, which could do regression, sanity and feature testing; already used by thousands of engineers and developers worldwide? Guess what, **it exists, it’s free, and you can start using it right now!**

pyATS (**Py**thon **A**utomated **T**est **S**ystems, to be pronounced "py A. T. S.") was first created as an internal project, to ease the validation of two OS versions. It has been made public in 2017 through **Cisco Devnet**.

This blog post will be the second one of a series on pyATS. Today, we will explore pyATS libraries (also known as Genie), and we will collect our first **parsed output**. More use cases are going to be covered in the next posts. 

# Other pyATS episodes

You've missed the first episode? You would like to read more? Below the list of published episodes:

| Episode 	| URL                                                                                              	| What's covered                                        	|
|---------	|--------------------------------------------------------------------------------------------------	|-------------------------------------------------------	|
| **1 - Install and use pyATS**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/){: .btn}  	|  What's pyATS, Install pyATS, Collect a CLI output 	|
| **2 - Parsing like  a pro**       	| [Link](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/) {: .btn} 	|  Explore pyATS libraries * Parse a CLI output        	|

# pyATS librairies overview

## pyATS building blocks

pyATS is made of three main building blocks:
- **pyATS**, the core block of this ecosystem. It’s a Python framework which leverages multiple Python libraries such as [Unicon](https://pypi.org/project/unicon/), providing a simplified connection experience to network devices. It supports **CLI**, **NETCONF** and **RESTCONF**. It enables network engineers and developers to start with small and simple test cases.
- **pyATS libraries** (also known as Genie) which provides everything you need for network testing such as parsers, triggers and APIs. 
- **XPRESSO**, the pyATS Web UI Dashboard.

You can read more about **pyATS ecosystem** in the [official documentation](https://pubhub.devnetcloud.com/media/pyats-getting-started/docs/intro/introduction.html).
{: .notice--info}

**pyATS libraries** are the pyATS **SDK** (**S**oftware **D**evelopment **K**it, a big toolbox) which contains all the tools that you need for **Network Test Automation**. It has been used internally at Cisco since 2010 for our automated testing. Yes! You can use the same tools that we use to automate the validation of your network.

You can read more about **pyATS librairies** in the [official documentation](https://developer.cisco.com/docs/genie-docs/).
{: .notice--info}

## pyATS libraries in a nutshell

* **1200** parsers accross 11 OS (as of February 2021),
* **32** supported models (more to come about them in a coming episode),
* Multiple tools for Test Harness such as triggers or traffic,
* Ansible and Robot libraries for easy integration with other tools.


You can find supported **parsers** and **models** in the [official documentation](https://pubhub.devnetcloud.com/media/genie-feature-browser/docs/#/).
{: .notice--info}

# Getting your hands dirty

Enough talking, let's code!

![keyboard cat_small2.png]({{site.baseurl}}/images/keyboard cat_small2.png){: .align-center}

**pyATS installation** has been covered in the [First episode](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/). Check it out to learn how to install pyATS.

## Parsing a CLI output from a device

In this first use case, we saw how we can get a **simple CLI output** (`show ip interface brief`) from an IOS XR device. 

In this second use case, we are going to see how we can **collect and parse a CLI output** (`show ip interface brief`).

In order for everyone to be able to run the code, we will use the [IOS XR always-on sandbox on Cisco Devnet](https://devnetsandbox.cisco.com/RM/Diagram/Index/e83cfd31-ade3-4e15-91d6-3118b867a0dd?diagramType=Topology). Feel free to adapt the code to use your own device(s). Below the sandbox information.

| Key               	| Value                    	|
|-------------------	|--------------------------	|
| IOS XRv 9000 host 	| sbx-iosxr-mgmt.cisco.com 	|
|     SSH Port      	|     8181                 	|
|     Username      	|     admin                	|
|     Password      	|     C1sco12345           	|

## Building a testbed

The simplest way to connect to a device is through a pyATS testbed file, written in YAML. This information will be used by **Unicon** to connect to the device and send the requested commands.

You can find the complete documentation on how to build a testbed [here](https://pubhub.devnetcloud.com/media/unicon/docs/user_guide/connection.html).
{: .notice--info}

**testbed.yaml**
{: .notice--primary}
<div class="highlight"><pre><span></span><span class="c1"># Step 0: list of devices</span>
<span class="nt">devices</span><span class="p">:</span>
  <span class="nt">iosxr1</span><span class="p">:</span>
    <span class="c1"># Step 1: OS and Type</span>
    <span class="nt">type</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr-devnet</span>
    <span class="nt">os</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">iosxr</span>
    <span class="c1"># Step 2: credentials</span>
    <span class="nt">credentials</span><span class="p">:</span>
      <span class="nt">default</span><span class="p">:</span>
        <span class="nt">username</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">admin</span>
        <span class="nt">password</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">C1sco12345</span>
    <span class="c1"># Step 3: connection parameters</span>
    <span class="nt">connections</span><span class="p">:</span>
      <span class="nt">vty</span><span class="p">:</span>
        <span class="nt">protocol</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">ssh</span>
        <span class="nt">ip</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">sbx-iosxr-mgmt.cisco.com</span>
        <span class="nt">port</span><span class="p">:</span> <span class="l l-Scalar l-Scalar-Plain">8181</span>
</pre></div>
{: .notice}

The `testbed.yaml` file is available [here](https://github.com/AntoineOrsoni/xrdocs-how-to-pyats/blob/master/1_structured_output/).
{: .notice--info}

The **testbed construction** has been covered in the [First episode](https://xrdocs.io/programmability/tutorials/pyats-series-install-and-use-pyats/). Have a look to understand how to build a testbed from scratch

## Collecting and parsing your first CLI output with pyATS libraries

Now, you know how to get a CLI output using pyATS. Getting a specific information in this big text output is easy for a human; but what about a computer? You got it, that's the power of the **pyATS libraries**: converting this big output **string** into a **dictionnary** where you can easily get a value by accessing a specific key.

Let's take an example.

**Raw CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
Interface                      IP-Address      Status          Protocol Vrf-Name
Loopback100                    1.1.1.100       Up              Up       default 
Loopback200                    1.1.1.200       Down            Down     Red 
</code>
</pre>
</div>

And now, the same output parsed with pyATS libraries.

**Parsed CLI output**
{: .notice--primary}
<div class="highlighter-rouge">
<pre class="highlight">
<code>
{
    "interface": {
        "Loopback100": {
            "ip_address": "1.1.1.100",
            "interface_status": "Up",
            "protocol_status": "Up",
            "vrf_name": "default",
        },
        "Loopback200": {
            "ip_address": "1.1.1.200",
            "interface_status": "Down",
            "protocol_status": "Down",
            "vrf_name": "Red",
        }
}
</code>
</pre>
</div>